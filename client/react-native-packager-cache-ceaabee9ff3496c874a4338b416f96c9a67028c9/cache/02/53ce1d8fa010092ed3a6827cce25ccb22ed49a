Object.defineProperty(exports,"__esModule",{value:true});










var _RefCountCache=require("./RefCountCache");var _RefCountCache2=babelHelpers.interopRequireDefault(_RefCountCache);

var _three=require("three");





/**
 * TextureManager manages remote and in-memory Textures, and makes sure that
 * they are shared among meshes and images when appropriate.
 *
 * The caching strategy is twofold:
 *   - Any textures that are currently in use are kept in a ref-counting cache.
 *     When no more references to that resource remain, the texture is removed
 *     from that cache but not yet disposed.
 *   - From there, it moves to a queue of fixed size. As new entries come
 *     in, older entries are ejected, and the underlying Texture is finally
 *     disposed.
 * This makes sure that textures in use are always available, but also covers
 * cases where a single reference to a texture is unmounted and soon remounted.
 *//**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */var TextureManager=function(){
function TextureManager(){var _this=this;var queueSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:10;babelHelpers.classCallCheck(this,TextureManager);
this._queueSize=queueSize;
// Map of URL to Textures
this._textureMap={};
// Map of URL to Promises that will be resolved when the texture loads
this._pendingTextures={};
// Queue of recently-used Textures waiting to be ejected
this._ejectionQueue=[];
// Promise resolvers for requests that occur before a source is registered
this._customTextureLoads={};
// Array of textures that need to be updated each frame
this._customTexturesWithUpdates=[];
// Reference-counting cache of Textures in use
this._refCountCache=new _RefCountCache2.default(
// cleanup method
function(path){
// move texture to queue
_this._ejectionQueue.push(path);
if(_this._ejectionQueue.length>_this._queueSize){
var ejected=_this._ejectionQueue.shift();
var tex=_this._textureMap[ejected];
delete _this._textureMap[ejected];
if(tex){
tex.dispose();
}
}
});

}

/**
   * Status methods, mostly for testing purposes
   */babelHelpers.createClass(TextureManager,[{key:"isTextureCached",value:function isTextureCached(
url){
return url in this._textureMap;
}},{key:"isTextureLoading",value:function isTextureLoading(

url){
return url in this._pendingTextures;
}},{key:"isTextureReferenced",value:function isTextureReferenced(

url){
return this._refCountCache.has(url);
}},{key:"isTextureInEjectionQueue",value:function isTextureInEjectionQueue(

url){
return this._ejectionQueue.indexOf(url)>-1;
}

/**
   * Load a Texture, returning a promise that is resolved when the Texture
   * is ready. This method does not manage any reference counting - the
   * component using the Texture should handle that as part of its lifecycle.
   * If a texture has been cached, it immediately resolves.
   * If other components are already waiting on the texture, hang on that Promise
   * Else, create a Promise that will be resolved when the texture is loaded
   */},{key:"getTextureForURL",value:function getTextureForURL(
url){var _this2=this;
if(this._textureMap[url]){
// Already registered source, return the texture
return Promise.resolve(this._textureMap[url]);
}
if(this._pendingTextures[url]){
// Other components are waiting on the source, wait on the same Promise
return this._pendingTextures[url];
}

if(url.startsWith('texture://')){
// Local texture
var _promise=new Promise(function(resolve,reject){
_this2._customTextureLoads[url]=resolve;
});
this._pendingTextures[url]=_promise;
return _promise;
}
// Network texture
var promise=new Promise(function(resolve,reject){
var loader=new _three.TextureLoader();
loader.setCrossOrigin('anonymous');
loader.load(
url,
function(texture){
_this2._textureMap[url]=texture;
delete _this2._pendingTextures[url];
resolve(texture);
},
undefined,
function(error){
reject(error);
});

});
this._pendingTextures[url]=promise;
return promise;
}},{key:"addReference",value:function addReference(

url){
if(url.startsWith('texture://')){
// We don't refcount in-memory textures
return;
}
if(this._refCountCache.has(url)){
this._refCountCache.addReference(url);
}else{
var index=this._ejectionQueue.indexOf(url);
if(index>-1){
// Promote it from the ejection queue
this._ejectionQueue.splice(index,1);
}
this._refCountCache.addEntry(url,true);
}
}},{key:"removeReference",value:function removeReference(

url){
if(url.startsWith('texture://')){
// We don't refcount in-memory textures
return;
}
if(this._refCountCache.has(url)){
this._refCountCache.removeReference(url);
}
}

/**
   * Register a local (in-memory) texture source with a unique identifier.
   */},{key:"registerLocalTextureSource",value:function registerLocalTextureSource(
name,source){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};
if(source instanceof HTMLCanvasElement){
var tex=new _three.Texture(source);
tex.needsUpdate=true;
var _url='texture://'+name;
this._textureMap[_url]=tex;
if(options.updateOnFrame){
this._customTexturesWithUpdates.push(tex);
}
delete this._pendingTextures[_url];
if(this._customTextureLoads[_url]){
this._customTextureLoads[_url](tex);
delete this._customTextureLoads[_url];
}
}else{
throw new Error('Unsupported texture source');
}
}

/**
   * Run updates once per frame
   */},{key:"frame",value:function frame()
{
var textures=this._customTexturesWithUpdates;
for(var i=0,length=textures.length;i<length;i++){
textures[i].needsUpdate=true;
}
}}]);return TextureManager;}();exports.default=TextureManager;