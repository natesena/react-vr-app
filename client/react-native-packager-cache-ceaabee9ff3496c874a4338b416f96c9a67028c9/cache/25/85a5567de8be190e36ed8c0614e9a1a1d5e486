Object.defineProperty(exports,"__esModule",{value:true});










var _three=require("three");
var _ovrui=require("ovrui");
var _bundleFromLocation=require("./bundleFromLocation");var _bundleFromLocation2=babelHelpers.interopRequireDefault(_bundleFromLocation);
var _createRootView=require("./createRootView");var _createRootView2=babelHelpers.interopRequireDefault(_createRootView);

































/**
 * VRInstance represents a mounted React VR application.
 * It contains such core pieces as an OVRUI player, a Three.js scene and camera,
 * and a React VR context used to execute a React application.
 *//**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */var VRInstance=function(){/**
   * Construct a VRInstance with a specific React VR application.
   * @param bundle - The relative or absolute path to the JS bundle containing
   *   the application
   * @param root - The name of the root component to render, as registered with
   *   AppRegistry from the React side.
   * @param parent (optional) - The element which will contain the VR window.
   *   It can be a DOM node, or the string id of a DOM node. If no parent is
   *   specified, the VR window will be directly attached to the body tag.
   * @param options (optional) - Extra options to configure the VRInstance.
   *   - camera: the Three.js camera. If none, a default camera is created.
   *   - cursorVisibility: sets when the cursor is shown. default=hidden
   *   - disableTouchPanning: disallow touch to pan camera on mobile. Defaults to false.
   *   - height: a number specifying the height of the VR window, in pixels
   *   - nativeModules: array of native module instances to register
   *   - scene: the Three.js scene to which ReactVR elements are added
   *   - width: a number specifying the width of the VR window, in pixels
   *   - allowCarmelDeeplink: attempts deeplinking to Carmel development
   *       browser when enabled defaults to enabled in development builds,
   *       disabled otherwise
   */
function VRInstance(
bundle,
root,
parent)

{var _this=this;var options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};babelHelpers.classCallCheck(this,VRInstance);
if(!bundle){
throw new Error('Cannot initialize ReactVR without specifying a bundle');
}
if(!root){
throw new Error('Cannot initialize ReactVR without specifying the root component');
}

// Initialize the scene that will hold our contents
this.scene=options.scene||new _three.Scene();

// Allow deep-linking to the Carmel development browser if it's not
// explicitly disabled
var allowCarmelDeeplink=!!options.allowCarmelDeeplink;

// Initialize a Player container, and attach it to the parent element
this.player=new _ovrui.Player({
elementOrId:parent,

// Optional Player configuration
antialias:options.hasOwnProperty('antialias')?options.antialias:false,
calculateVerticalFOV:options.calculateVerticalFOV,
camera:options.camera,
canvasAlpha:options.hasOwnProperty('canvasAlpha')?options.antialias:true,
width:options.width,
height:options.height,
onEnterVR:function onEnterVR(){return _this._onEnterVR();},
onExitVR:function onExitVR(){return _this._onExitVR();},
allowCarmelDeeplink:allowCarmelDeeplink,
disableTouchPanning:options.disableTouchPanning,
pixelRatio:options.pixelRatio,
hideFullscreen:options.hideFullscreen,
hideCompass:options.hideCompass});


var defaultAssetRoot='static_assets/';



var assetRoot=options.assetRoot||defaultAssetRoot;
if(!assetRoot.endsWith('/')){
assetRoot+='/';
}

// Initialize a GuiSys to use with React
var guiOptions={
cursorVisibility:options.hasOwnProperty('cursorVisibility')?
options.cursorVisibility:
'hidden',
font:options.font,
raycasters:options.raycasters};

this.guiSys=new _ovrui.GuiSys(this.scene,guiOptions);
this.rootView=(0,_createRootView2.default)(this.guiSys,root,{
// Name of the mounted root module, from AppRegistry
assetRoot:assetRoot,
bridge:options.bridge,
bundle:(0,_bundleFromLocation2.default)(bundle),
customViews:options.customViews,
enableHotReload:options.enableHotReload,
initialProps:options.initialProps,
isLowLatency:!this.player.isMobile,
nativeModules:options.nativeModules});


this._frame=this._frame.bind(this);
}

/**
   * Runs once per frame, to update each of the various components of this
   * VR application.
   * @param timestamp - current time in milliseconds; passed by the browser as
   *   the argument to the requestAnimationFrame callback
   */babelHelpers.createClass(VRInstance,[{key:"_frame",value:function _frame(
timestamp){
// Run custom render method
if(typeof this.render==='function'){
this.render(timestamp);
}
var camera=this.player.camera;
this.player.frame();
// Get updates from GuiSys
this.guiSys.frame(camera,this.player.renderer);
// Get updates from RN
this.rootView.frame(camera);
// Render frame to output device
var subScenes=this.guiSys.getOffscreenRenders();
for(var item in subScenes){
if(!subScenes.hasOwnProperty(item)){
continue;
}
var params=subScenes[item];
this.player.renderOffscreen(params.scene,params.camera,params.renderTarget);
}
this.player.render(this.scene);

if(this._looping){
this.player.requestAnimationFrame(this._frame);
}
}},{key:"_onEnterVR",value:function _onEnterVR()

{
this.rootView.context&&
this.rootView.context.callFunction('RCTDeviceEventEmitter','emit',['onEnterVR',[]]);
}},{key:"_onExitVR",value:function _onExitVR()

{
this.rootView.context&&
this.rootView.context.callFunction('RCTDeviceEventEmitter','emit',['onExitVR',[]]);
}

/**
   * Start rendering the application
   */},{key:"start",value:function start()
{
this._looping=true;
this.player.requestAnimationFrame(this._frame);
}

/**
   * Stop rendering the application
   */},{key:"stop",value:function stop()
{
this._looping=false;
}

/**
   * Return the camera being used to render the scene.
   */},{key:"camera",value:function camera()
{
return this.player.camera;
}},{key:"registerTextureSource",value:function registerTextureSource(

name,source){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};
if(this.rootView&&this.rootView.context){
this.rootView.context.registerTextureSource(name,source,options);
}
}

/**
   * Mount a new root component on an existing scenegraph node, returning its
   * unique identifier
   */},{key:"mountComponent",value:function mountComponent(
name,initialProps,container){
if(this.rootView){
var tag=this.rootView.context.createRootView(name,initialProps,container);
return tag;
}
return null;
}

/**
   * Unmount a root component, given its unique identifier
   */},{key:"unmountComponent",value:function unmountComponent(
tag){
if(this.rootView){
this.rootView.context.destroyRootView(tag);
}
}}]);return VRInstance;}();exports.default=VRInstance;