Object.defineProperty(exports,"__esModule",{value:true});










var _Module2=require("./Module");var _Module3=babelHelpers.interopRequireDefault(_Module2);



/**
 * WebSocketModule is an implementation of the websocket interface used by React native.
 * These methods are not intended to be called directly. Rather, they are
 * called remotely by the WebSocketModule module on the React side.
 * @class WebSocketModule
 * @extends Module
 */var
WebSocketModule=function(_Module){babelHelpers.inherits(WebSocketModule,_Module);



/**
   * Constructs a WebSocketModule with a specific React Native Context
   */
function WebSocketModule(rnctx){babelHelpers.classCallCheck(this,WebSocketModule);var _this=babelHelpers.possibleConstructorReturn(this,(WebSocketModule.__proto__||Object.getPrototypeOf(WebSocketModule)).call(this,
'WebSocketModule'));
_this._sockets={};
_this._rnctx=rnctx;return _this;
}

/**
   * Establish a connection and associate with socketID. socketID is used for future
   * communication with React
   * @param url - string Url to connect to
   * @param protocols - protocols for creating the WebSocket instance
   * @param options - currently unused
   * @param socketId - ID used to represent this connection in React
   */babelHelpers.createClass(WebSocketModule,[{key:"connect",value:function connect(
url,protocols,options,socketId){var _this2=this;
var socket=protocols?new WebSocket(url,protocols):new WebSocket(url);
socket.binaryType='arraybuffer';
this._sockets[String(socketId)]=socket;

// set the onclose, onerror and onmessage functions so that the
// React event can be dispatched
socket.onclose=function(event){
var payload={
id:socketId,
code:event.code,
reason:event.reason};

_this2._rnctx.callFunction('RCTDeviceEventEmitter','emit',['websocketClosed',payload]);
};
socket.onerror=function(event){
var payload={
id:socketId,
message:'Native WebSocket error'};

_this2._rnctx.callFunction('RCTDeviceEventEmitter','emit',['websocketFailed',payload]);
};
socket.onmessage=function(event){
var data=event.data;
if(data instanceof ArrayBuffer){
// Convert arraybuffer to string because the current bridge format is
// automatically stringified to account for metadata and to speed up
// older versions of Blink. We may be able to avoid this indirection
// later on.
var arr=new Uint8Array(data);
var str=new Array(arr.byteLength);
for(var i=0;i<str.length;i++){
str[i]=String.fromCharCode(arr[i]);
}
data=btoa(str.join(''));
}
var payload={
id:socketId,
type:typeof event.data==='string'?'string':'binary',
data:data};

_this2._rnctx.callFunction('RCTDeviceEventEmitter','emit',['websocketMessage',payload]);
};
socket.onopen=function(event){
var payload={
id:socketId};

_this2._rnctx.callFunction('RCTDeviceEventEmitter','emit',['websocketOpen',payload]);
};
}

/**
   * internal function to send the data
   * maps the React socketID to the instance of WebSocket
   */},{key:"_send",value:function _send(
data,socketId){
var socket=this._sockets[String(socketId)];
if(!socket){
throw new Error('Error while sending data to WebSocket: no such socket');
}
socket.send(data);
}

/**
   * send
   * function called by the React code through messages
   * @param data - data from react
   * @param socketId - React socket id
   */},{key:"send",value:function send(
data,socketId){
this._send(data,socketId);
}

/**
   * sendBinary
   * function called by the React code through messages
   * @param data - data from react
   * @param socketId - React socket id
   */},{key:"sendBinary",value:function sendBinary(
data,socketId){
var chars=atob(data);
var array=new Uint8Array(chars.length);
for(var i=0;i<chars.length;i++){
array[i]=chars.charCodeAt(i)&255;
}
this._send(array.buffer,socketId);
}

/**
   * ping
   * Unsupported in WebVR due to
   * "Cannot send a ping. Browser WebSocket APIs are not capable of sending specific opcodes"
   * @param socketId - React socket id
   */},{key:"ping",value:function ping(
socketId){
throw new Error(
'Cannot send a ping. Browser WebSocket APIs are not capable of sending specific opcodes');

}

/**
   * close
   * function called by the React code through messages
   * @param codeOrId - if reason is undefined or sockedId is undefined this is id, otherwise
   *                   it is the code to report to the websocket
   * @param reason - reason distributed to WebSocket close, maybe undefined
   * @param socketId - React socket id or maybe undefined in which codeorID contains the socket
   */},{key:"close",value:function close(
codeOrId,reason,socketId){
var id=void 0;
if(typeof reason!=='undefined'&&typeof socketId!=='undefined'){
id=String(socketId);
var socket=this._sockets[id];
if(!socket){
return;
}
socket.close(codeOrId,reason);
}else{
id=String(codeOrId);
var _socket=this._sockets[id];
if(!_socket){
return;
}
_socket.close();
}
delete this._sockets[id];
}}]);return WebSocketModule;}(_Module3.default);/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */exports.default=WebSocketModule;