Object.defineProperty(exports,"__esModule",{value:true});exports.ReactNativeContext=undefined;










var _AndroidConstants=require("./Modules/AndroidConstants");var _AndroidConstants2=babelHelpers.interopRequireDefault(_AndroidConstants);
var _AsyncLocalStorage=require("./Modules/AsyncLocalStorage");var _AsyncLocalStorage2=babelHelpers.interopRequireDefault(_AsyncLocalStorage);
var _ControllerInfo=require("./Modules/ControllerInfo");var _ControllerInfo2=babelHelpers.interopRequireDefault(_ControllerInfo);
var _DeviceInfo=require("./Modules/DeviceInfo");var _DeviceInfo2=babelHelpers.interopRequireDefault(_DeviceInfo);
var _ExternalAssets=require("./Modules/ExternalAssets");var _ExternalAssets2=babelHelpers.interopRequireDefault(_ExternalAssets);
var _GlyphTextures=require("./Modules/GlyphTextures");var _GlyphTextures2=babelHelpers.interopRequireDefault(_GlyphTextures);
var _History=require("./Modules/History");var _History2=babelHelpers.interopRequireDefault(_History);
var _LinkingManager=require("./Modules/LinkingManager");var _LinkingManager2=babelHelpers.interopRequireDefault(_LinkingManager);
var _Location=require("./Modules/Location");var _Location2=babelHelpers.interopRequireDefault(_Location);
var _LocationObserver=require("./Modules/LocationObserver");var _LocationObserver2=babelHelpers.interopRequireDefault(_LocationObserver);
var _Networking=require("./Modules/Networking");var _Networking2=babelHelpers.interopRequireDefault(_Networking);
var _RCTResourceManager=require("./Utils/RCTResourceManager");
var _RCTInputControls=require("./Utils/RCTInputControls");
var _RCTHeadModel=require("./Utils/RCTHeadModel");var _RCTHeadModel2=babelHelpers.interopRequireDefault(_RCTHeadModel);
var _RCTVideoModule=require("./Modules/RCTVideoModule");var _RCTVideoModule2=babelHelpers.interopRequireDefault(_RCTVideoModule);
var _RCTAudioModule=require("./Modules/RCTAudioModule");var _RCTAudioModule2=babelHelpers.interopRequireDefault(_RCTAudioModule);
var _TextureManager=require("./Utils/TextureManager");var _TextureManager2=babelHelpers.interopRequireDefault(_TextureManager);
var _Timing=require("./Modules/Timing");var _Timing2=babelHelpers.interopRequireDefault(_Timing);
var _UIManager=require("./Modules/UIManager");var _UIManager2=babelHelpers.interopRequireDefault(_UIManager);
var _WebSocketModule=require("./Modules/WebSocketModule");var _WebSocketModule2=babelHelpers.interopRequireDefault(_WebSocketModule);
var _ReactVRConstants=require("./Modules/ReactVRConstants");var _ReactVRConstants2=babelHelpers.interopRequireDefault(_ReactVRConstants);
var _RCTExceptionsManager=require("./Modules/RCTExceptionsManager");var _RCTExceptionsManager2=babelHelpers.interopRequireDefault(_RCTExceptionsManager);
var _RCTSourceCode=require("./Modules/RCTSourceCode");var _RCTSourceCode2=babelHelpers.interopRequireDefault(_RCTSourceCode);
var _ovrui=require("ovrui");var OVRUI=babelHelpers.interopRequireWildcard(_ovrui);
var _three=require("three");var THREE=babelHelpers.interopRequireWildcard(_three);
















var ROOT_VIEW_INCREMENT=10;/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */var ONMOVE_EPSILON=0.0001;/**
 * replaceHiddenAttributes is a callback function used by the JSON.stringify,
 * the purpose is to prevent the serialization of any key that starts in '_' as
 * these are denoted to be private to the class
 **/function replaceHiddenAttributes(key,value){if(key.charAt&&key.charAt(0)==='_'){return undefined;}else{return value;}
}

/**
 * describe
 * Reflects the contents of a the class over to React code
 * this is used within init to create a contract between the runtime and React
 * as to which module corresponds to a specfic index
 * @param ctx - React Context
 **/
function describe(ctx){
var remoteModuleConfig=[];
for(var _iterator=ctx.modules,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[typeof Symbol==="function"?Symbol.iterator:"@@iterator"]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var module=_ref;
var description=module._describe();



remoteModuleConfig.push(description);
}

return remoteModuleConfig;
}

/**
 * ReactNativeContext is the main object for communicating to and from the React bundle
 * The react bundle runs asynchronously in a webworker so that the main UI and render thread
 * of the browser is not interrupted by work within react.
 * On construction the context will start the WebWorker and register a callback for handling
 * the messages which are handled in the `frame` function
 * As the webworker runs asynchronously calls to and from react are latent and therefore will
 * not have a return value. JavaScript callbacks and addional messages should be used to handle
 * responses
 * Order of API use:
 * 1) Create the Context
 * 2) register any external modules through `registerModule`
 * 3) init the bundle, this causes the bundle to be loaded from the url provided but prior to
 *    that creates a json description of the regstered modules. This description - created by
 *    `describe` - determines the details of the protocol that is used to communicate with the
 *    webworker. It is important that both the modules and the registered views of UIManager
 *    provide the necessary detail, for modules the majority of the work is handled via
 *    Module.describe however for views any properties that need to be communicated are across
 *    the WebWorker need to be described in `NativeProps`. Note any properties starting in '_'
 *    will be determined to be hidden and any functions starting with '$' will be determined to be
 *    async/promise functions and take an extra two callback IDs to denote success and fail - eg
 *    LinkingModule: openURL
 * 4) createRootView
 *    A root view is the main view created by the runtime code, this will then cause a registerd
 *    module to be created with the necessary Props
 *    see `AppRegistry.registerComponent('main', () => Main);`
 *    The root view tag is returned and can be used to update the props for the root view or
 *    delete the view
 * 5) start of render loop
 * 6) call frame function on context
 *    `frame` must be called within a requestAnimationFrame callback this pumps the webworker and
 *    distributes the messages obtained from the bridge. This is also where the <Scene> transform
 *    is applied, if one is present (not to the camera directly but to a camera parent object that
 *    we create and manage here; if camera already has a parent we log a warning and do nothing).
 * 7) update root view as required
 *    Optionally and as required the props on the root view can be updated using the root tag
 *    obtained from `createRootView`
 * 8) destroyRootView
 *    the destruction of the root view causes the entire view hierarchy to be deleted
 * 9) shutdown
 *    Will release the resrouces associated with the context, once shutdown an init is no longer
 *    possible
 **/var
ReactNativeContext=exports.ReactNativeContext=function(){























/**
   * Construct a ReactNativeContext given the gui and url for the bridge
   * the construction registers the core modules used by most applications
   * new modules can be registered after this but prior to the init call
   * @param guiSys - instance of OVRUI.guiSys
   * @param bridgeURL - url of location of bridge
   */
function ReactNativeContext(guiSys,bridge){var _this=this;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};babelHelpers.classCallCheck(this,ReactNativeContext);
this.modules=[];
this.currentRootTag=1;
this.bridge=bridge;
this.guiSys=guiSys;
this.messages=[];
this.isLowLatency=!!options.isLowLatency;// Whether this context should target 90fps
this.enableHotReload=!!options.enableHotReload;// Whether this context should enable hot reload

this.lastHit=null;
this.lastLocalIntersect=null;
this.lastSource=null;

this.UIManager=new _UIManager2.default(this,guiSys,options.customViews);
this.Timing=new _Timing2.default(this);
this.RCTResourceManager=new _RCTResourceManager.RCTResourceManager();
this.RCTInputControls=new _RCTInputControls.RCTInputControls(this,guiSys);
this.HeadModel=new _RCTHeadModel2.default(this);
this.VideoModule=new _RCTVideoModule2.default(this);
this.AudioModule=new _RCTAudioModule2.default(this);
this.TextureManager=new _TextureManager2.default();
this.GlyphTextures=new _GlyphTextures2.default(this);
this._moduleForTag=[];
this._cameraParentFromTag=[];

// register the core modules
this.registerModule(this.UIManager);
this.registerModule(new _AndroidConstants2.default());
this.registerModule(new _AsyncLocalStorage2.default(this));
this.registerModule(new _ControllerInfo2.default(this));
this.registerModule(new _DeviceInfo2.default());
this.registerModule(new _History2.default(this));
this.registerModule(new _Networking2.default(this));
this.registerModule(new _LinkingManager2.default(this));
this.registerModule(new _Location2.default(this));
this.registerModule(new _LocationObserver2.default(this));
this.registerModule(this.Timing);
this.registerModule(this.VideoModule);
this.registerModule(this.AudioModule);
this.registerModule(new _WebSocketModule2.default(this));
this.registerModule(new _ReactVRConstants2.default());
this.registerModule(new _RCTExceptionsManager2.default());
this.registerModule(new _RCTSourceCode2.default(this));
this.registerModule(new _ExternalAssets2.default(options.assetRoot||''));
this.registerModule(this.GlyphTextures);

// Register event listener to Guisys
guiSys.eventDispatcher.addEventListener('GuiSysEvent',this._onGuiSysEvent.bind(this));
guiSys.eventDispatcher.addEventListener('UIViewEvent',this._onUIViewEvent.bind(this));

// register the worker onmessage function
// messages are not execute at point of recieving
// but queue for later dispatch in the `frame` function
this.bridge.setMessageHandler(function(msg){
if(msg.cmd==='exec'){
var results=msg.results;
if(results&&results.length){
_this.messages.push(results);
}
}
});
}

/**
   * initialises the WebWorker with the bundle
   * @param bundle - url of the bundle
   */babelHelpers.createClass(ReactNativeContext,[{key:"init",value:function init(
bundle){
this.bridge.postMessage(
JSON.stringify(
{
cmd:'moduleConfig',
moduleConfig:{remoteModuleConfig:describe(this)}},

replaceHiddenAttributes));



this.bridge.postMessage(JSON.stringify({cmd:'bundle',bundleName:bundle}));
if(this.enableHotReload){
var bundleURL=new URL(bundle);
console.warn('HotReload on '+bundle);
this.callFunction('HMRClient','enable',[
'vr',
bundleURL.pathname.toString().substr(1),
bundleURL.hostname,
bundleURL.port]);

}
}

/**
   * shutdown the react native context
   */},{key:"shutdown",value:function shutdown()
{
for(var _iterator2=this.modules,_isArray2=Array.isArray(_iterator2),_i2=0,_iterator2=_isArray2?_iterator2:_iterator2[typeof Symbol==="function"?Symbol.iterator:"@@iterator"]();;){var _ref2;if(_isArray2){if(_i2>=_iterator2.length)break;_ref2=_iterator2[_i2++];}else{_i2=_iterator2.next();if(_i2.done)break;_ref2=_i2.value;}var module=_ref2;
if(typeof module.shutdown==='function'){
module.shutdown();
}
}
}

/**
   * creates a root view given the registered modules and optional props
   * @param module - name of module registered in the react bundle
   * @param props - props that is posted to the registered module
   * @return returns the tag of the rootview
   */},{key:"createRootView",value:function createRootView(
module,props,container){
var tag=this.currentRootTag;
// TODO: Root tags should be sourced from UIManager instead, which
// is aware of availability.
this.currentRootTag+=ROOT_VIEW_INCREMENT;
this.bridge.postMessage(
JSON.stringify({
cmd:'exec',
module:'AppRegistry',
function:'runApplication',
args:[module,{initialProps:props,rootTag:tag}]}));


this._moduleForTag[tag]=module;
if(!container){
this._cameraParentFromTag[tag]=new THREE.Object3D();
}
this.UIManager.createRootView(tag,container);
return tag;
}

/**
   * updated a root view with new props
   * @param tag - root view tag returned from createRootView
   * @param props - props that is posted to the registered module
   */},{key:"updateRootView",value:function updateRootView(
tag,props){
this.bridge.postMessage(
JSON.stringify({
cmd:'exec',
module:'AppRegistry',
function:'runApplication',
args:[this._moduleForTag[tag],{initialProps:props,rootTag:tag}]}));


}

/**
   * deletes the root view
   * @param tag - root view tag returned from createRootView
   */},{key:"destroyRootView",value:function destroyRootView(
tag){
delete this._moduleForTag[tag];
var cameraParent=this._cameraParentFromTag[tag];
if(cameraParent){
// Detach children; typically there is only 1 child, the camera.
for(var _iterator3=cameraParent.children,_isArray3=Array.isArray(_iterator3),_i3=0,_iterator3=_isArray3?_iterator3:_iterator3[typeof Symbol==="function"?Symbol.iterator:"@@iterator"]();;){var _ref3;if(_isArray3){if(_i3>=_iterator3.length)break;_ref3=_iterator3[_i3++];}else{_i3=_iterator3.next();if(_i3.done)break;_ref3=_i3.value;}var child=_ref3;
cameraParent.remove(child);
}
delete this._cameraParentFromTag[tag];
}
this.bridge.postMessage(
JSON.stringify({
cmd:'exec',
module:'AppRegistry',
function:'unmountApplicationComponentAtRootTag',
args:[tag]}));


}

/**
   * internal function that processing the gui event and distributes to React code
   * @param event - event object passed from guiSys
   */},{key:"_onGuiSysEvent",value:function _onGuiSysEvent(
event){
switch(event.eventType){
case OVRUI.GuiSysEventType.HIT_CHANGED:
if(
this.lastHit!==event.args.currentHit||
this.lastSource!==event.args.currentSource)
{
this.lastHit=event.args.currentHit;
this.lastSource=event.args.currentSource;
}
break;
default:
break;}

}

/**
   * internal function that processing the uiview event and distributes to React code
   * @param event - event object passed from uiView
   */},{key:"_onUIViewEvent",value:function _onUIViewEvent(
event){
switch(event.eventType){
case OVRUI.UIViewEventType.FOCUS_LOST:
{
var viewTag=event.view?this.getHitTag(event.view):undefined;
var targetTag=event.args.target?this.getHitTag(event.args.target):undefined;
var payload={
target:targetTag,
source:event.args.source};

if(viewTag){
// Dispatch exit event
this.callFunction('RCTEventEmitter','receiveEvent',[viewTag,'topExit',payload]);
}
}
break;
case OVRUI.UIViewEventType.FOCUS_GAINED:
{
var _viewTag=event.view?this.getHitTag(event.view):undefined;
var _targetTag=event.args.target?this.getHitTag(event.args.target):undefined;
var _payload={
target:_targetTag,
source:event.args.source};

if(_viewTag){
// Dispatch enter event
this.callFunction('RCTEventEmitter','receiveEvent',[_viewTag,'topEnter',_payload]);
}
}
break;
default:
break;}

}

/**
   * frame update, services the modules and views
   * must be called regularly to ensure the messages from the WebWorker are distributed
   * @param camera - three.js camera used to view the scene
   * @param rootTag - the React Tag for the root of the scene
   */},{key:"frame",value:function frame(
camera,rootTag){
var frameStart=window.performance?performance.now():Date.now();
this.Timing&&this.Timing.frame(frameStart);
// Send current cursor position if the currently-hit view is listening
if(this.lastHit&&this.lastHit.owner&&this.lastHit.owner.receivesMoveEvent){
var intersect=this.guiSys.getLastLocalIntersect();
if(!intersect){
this.lastLocalIntersect=null;
}
if(intersect){
var lastLocalIntersect=this.lastLocalIntersect;
if(
!lastLocalIntersect||
Math.abs(intersect[0]-lastLocalIntersect[0])>ONMOVE_EPSILON||
Math.abs(intersect[1]-lastLocalIntersect[1])>ONMOVE_EPSILON)
{
var viewTag=this.getHitTag(this.lastHit);
var payload={offset:intersect};
this.callFunction('RCTEventEmitter','receiveEvent',[viewTag,'topMove',payload]);
this.lastLocalIntersect=intersect;
}
}
}
this.bridge.postMessage(JSON.stringify({cmd:'flush'}));
for(var _iterator4=this.messages,_isArray4=Array.isArray(_iterator4),_i4=0,_iterator4=_isArray4?_iterator4:_iterator4[typeof Symbol==="function"?Symbol.iterator:"@@iterator"]();;){var _ref4;if(_isArray4){if(_i4>=_iterator4.length)break;_ref4=_iterator4[_i4++];}else{_i4=_iterator4.next();if(_i4.done)break;_ref4=_i4.value;}var results=_ref4;
if(results&&results.length>=3){
var moduleIndex=results[0];
var funcIndex=results[1];
var params=results[2];
for(var i=0;i<moduleIndex.length;i++){
this.modules[moduleIndex[i]]._functionMap[funcIndex[i]].apply(
this.modules[moduleIndex[i]],
params[i]);

}
}
}

this.messages=[];
this.UIManager&&this.UIManager.frame(frameStart);
this.HeadModel&&this.HeadModel.frame(camera);
this.VideoModule&&this.VideoModule.frame();
this.AudioModule&&this.AudioModule.frame(camera);
this.TextureManager.frame();

if(rootTag){
this._applySceneTransform(camera,rootTag);
}

// Last, check if there is any remaining frame time, and use it to run idle
// callbacks
this.Timing&&this.Timing.idle(frameStart);
}

/**
    * Updates the camera parent with current <Scene> transform, if any.
    * Do nothing if there is no <Scene>, the <Scene> has no transform property,
    * or the camera already has a parent object.
   **/},{key:"_applySceneTransform",value:function _applySceneTransform(
camera,rootTag){
var worldMatrix=this.UIManager.getSceneCameraTransform(rootTag);
var cameraParent=this._cameraParentFromTag[rootTag];

// worldMatrix is null if no <Scene> or <Scene> has no transform property.
// We may have set cameraParentFromTag[rootTag] to null (and printed a
// console warning) if there was a <Scene> transform but the camera already
// had a parent. Return immediately in both cases.
if(!worldMatrix||!cameraParent){
return;
}

// Don't overwrite a parent object that isn't ours.
if(camera.parent&&camera.parent.uuid!==cameraParent.uuid){
console.warn("Camera object already has a parent; Use of 'transform' property on <Scene> will have no effect.");



this._cameraParentFromTag[rootTag]=null;
return;
}

// One-time initialization: parent the camera object under cameraParent.
// We use a parent to avoid modifying the camera's local transform, which
// is being updated with positional tracking data when available.
if(cameraParent.children.length===0){
cameraParent.add(camera);
}

// In Three.js, object.matrix and object.matrixWorld represent the local and
// global transforms. When matrixAutoUpdate is enabled (which is the default)
// both are recomputed each frame (in WebGLRenderer.render), matrix from the
// object's position, rotation, and scale attributes and matrixWorld from the
// parent hierarchy (if no parent, matrix and matrixWorld are identical).

// We disable cameraParent.matrixAutoUpdate, since we update the matrix here
// manually and we explicitly call updateMatrixWorld (which recomputes the
// global transform of an object and its children).
cameraParent.matrixAutoUpdate=false;
cameraParent.matrix.fromArray(worldMatrix);
cameraParent.updateMatrixWorld(true);
}

/**
    * getHitTag
    * @param hit - scene object
    * @returns the tag of the closest view with a tag or undefined if not found
   **/},{key:"getHitTag",value:function getHitTag(
hit){
while(hit){
if(hit.tag){
return hit.tag;
}
hit=hit.parent;
}
return undefined;
}

/**
    * calls a particular function within a react module
    * @param moduleName - module within the react bundle
    * @param functionName - name of the function
    * @param args - array of args passed to react bundle over webworker
   **/},{key:"callFunction",value:function callFunction(
moduleName,functionName,args){
this.bridge.postMessage(
JSON.stringify({
cmd:'exec',
module:moduleName,
function:functionName,
args:args}));


}

/**
    * calls a particular callback within a react module
    * @param id - callback specified by react
    * @param args - array of args passed to react bundle over webworker
   **/},{key:"invokeCallback",value:function invokeCallback(
id,args){
this.bridge.postMessage(
JSON.stringify({
cmd:'invoke',
id:id,
args:args}));


}

/**
    * registers a module for use by the context
    * must be specified prior to calling init
    * @param module - instance of a module to register, extends Module
   **/},{key:"registerModule",value:function registerModule(
module){
this.modules.push(module);
}},{key:"registerTextureSource",value:function registerTextureSource(

name,source){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};
this.TextureManager.registerLocalTextureSource(name,source,options);
}}]);return ReactNativeContext;}();