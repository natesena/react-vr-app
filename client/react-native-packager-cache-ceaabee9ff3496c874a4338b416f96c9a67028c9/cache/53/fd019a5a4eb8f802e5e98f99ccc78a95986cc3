Object.defineProperty(exports,"__esModule",{value:true});










var _Box=require("../Views/Box");var _Box2=babelHelpers.interopRequireDefault(_Box);
var _Cylinder=require("../Views/Cylinder");var _Cylinder2=babelHelpers.interopRequireDefault(_Cylinder);
var _Plane=require("../Views/Plane");var _Plane2=babelHelpers.interopRequireDefault(_Plane);
var _Sphere=require("../Views/Sphere");var _Sphere2=babelHelpers.interopRequireDefault(_Sphere);
var _Image=require("../Views/Image");var _Image2=babelHelpers.interopRequireDefault(_Image);
var _View=require("../Views/View");var _View2=babelHelpers.interopRequireDefault(_View);
var _Pano=require("../Views/Pano");var _Pano2=babelHelpers.interopRequireDefault(_Pano);
var _LiveEnvCamera=require("../Views/LiveEnvCamera");var _LiveEnvCamera2=babelHelpers.interopRequireDefault(_LiveEnvCamera);
var _Model=require("../Views/Model");var _Model2=babelHelpers.interopRequireDefault(_Model);
var _Scene=require("../Views/Scene");var _Scene2=babelHelpers.interopRequireDefault(_Scene);
var _Sound=require("../Views/Sound");var _Sound2=babelHelpers.interopRequireDefault(_Sound);
var _Text=require("../Views/Text");var _Text2=babelHelpers.interopRequireDefault(_Text);
var _RawText=require("../Views/RawText");var _RawText2=babelHelpers.interopRequireDefault(_RawText);
var _Video=require("../Views/Video");var _Video2=babelHelpers.interopRequireDefault(_Video);
var _VideoPano=require("../Views/VideoPano");var _VideoPano2=babelHelpers.interopRequireDefault(_VideoPano);
var _AmbientLight=require("../Views/AmbientLight");var _AmbientLight2=babelHelpers.interopRequireDefault(_AmbientLight);
var _DirectionalLight=require("../Views/DirectionalLight");var _DirectionalLight2=babelHelpers.interopRequireDefault(_DirectionalLight);
var _PointLight=require("../Views/PointLight");var _PointLight2=babelHelpers.interopRequireDefault(_PointLight);
var _SpotLight=require("../Views/SpotLight");var _SpotLight2=babelHelpers.interopRequireDefault(_SpotLight);
var _CylindricalPanel=require("../Views/CylindricalPanel");var _CylindricalPanel2=babelHelpers.interopRequireDefault(_CylindricalPanel);
var _QuadPanel=require("../Views/QuadPanel");var _QuadPanel2=babelHelpers.interopRequireDefault(_QuadPanel);
var _Prefetch=require("../Views/Prefetch");var _Prefetch2=babelHelpers.interopRequireDefault(_Prefetch);

var _Module2=require("./Module");var _Module3=babelHelpers.interopRequireDefault(_Module2);
var _three=require("three");var THREE=babelHelpers.interopRequireWildcard(_three);
var _ovrui=require("ovrui");var OVRUI=babelHelpers.interopRequireWildcard(_ovrui);
var _Yoga=require("../Utils/Yoga.bundle");var Yoga=babelHelpers.interopRequireWildcard(_Yoga);
















// the list of styles that don't invalidate layout uses black list as this is an optimization
// and given that it is better to be conservative.
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */var STYLES_THAT_DONT_ALTER_LAYOUT={color:true,backgroundColor:true,transform:true,borderColor:true,opacity:true};/**
 * Class that is used to receive React commands from JS and translate them into a
 * runtime native view hierarchy.
 * Some of the functions within this module are to be called externally and these
 * are marked public in their comment.
 * However the majority are to be called from React code through messages
 *
 * UIManager manages the view types available - which must be registered ahead on a react
 * context init - as well as being the module that handles the view and property
 * manipulations of React. The React version of the properties is considered to be the
 * source of truth and UIManager should respect these accordingly
 *
 * The asscociation of a view with the react version is via the react tag, a unique id
 * managed by the react code, the exeception is a root view tag which by contract is an
 * id which when divided by 10 there is a remainder of 1
 *
 * UIManager will also make the necessary calls to layout the views via css-layout
 * within the frame function. This is based on flexbox.
 * @class UIManager
 * @extends Module
 */var UIManager=function(_Module){babelHelpers.inherits(UIManager,_Module);
















/**
   * Construct a UIManager with a React Native Context and an OVRUI GuiSys.
   */
function UIManager(rnctx,guiSys){var customViews=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];babelHelpers.classCallCheck(this,UIManager);var _this=babelHelpers.possibleConstructorReturn(this,(UIManager.__proto__||Object.getPrototypeOf(UIManager)).call(this,
'UIManager'));
_this._rnctx=rnctx;
_this._guiSys=guiSys;

_this.customDirectEventTypes={
topLayout:{registrationName:'onLayout'},
topLoadStart:{registrationName:'onLoadStart'},
topLoad:{registrationName:'onLoad'},
topLoadEnd:{registrationName:'onLoadEnd'},
topEnter:{registrationName:'onEnter'},
topExit:{registrationName:'onExit'},
topMove:{registrationName:'onMove'},
// Media Events
topDurationChange:{registrationName:'onDurationChange'},
topEnded:{registrationName:'onEnded'},
topTimeUpdate:{registrationName:'onTimeUpdate'},
topPlayStatusChange:{registrationName:'onPlayStatusChange'}};

_this.customBubblingEventTypes={
topChange:{
phasedRegistrationNames:{
bubbled:'onChange',
captured:'onChangeCapture'}},


topInput:{
phasedRegistrationNames:{
bubbled:'onInput',
captured:'onInputCapture'}},


topHeadPose:{
phasedRegistrationNames:{
bubbled:'onHeadPose',
captured:'onHeadPoseCapture'}}};




_this._views={};
_this._viewTypes={};
_this._viewCreator={};
_this._rootViews={};
_this._viewsOfType={};
_this._layoutAnimation=null;
_this.registerViewType('RCTView',_View2.default.describe(),function(){
return new _View2.default(guiSys);
});
_this.registerViewType('LiveEnvCamera',_LiveEnvCamera2.default.describe(),function(){
return new _LiveEnvCamera2.default(guiSys);
});
_this.registerViewType('RCTImageView',_Image2.default.describe(),function(){
return new _Image2.default(guiSys,rnctx);
});
_this.registerViewType('Pano',_Pano2.default.describe(),function(){
return new _Pano2.default(guiSys,rnctx);
});
_this.registerViewType('Model',_Model2.default.describe(),function(){
return new _Model2.default(guiSys,rnctx);
});
_this.registerViewType('Scene',_Scene2.default.describe(),function(){
return new _Scene2.default(guiSys);
});
_this.registerViewType('Sound',_Sound2.default.describe(),function(){
return new _Sound2.default(guiSys,rnctx);
});
_this.registerViewType('RCTText',_Text2.default.describe(),function(){
return new _Text2.default(guiSys);
});
_this.registerViewType('RCTRawText',_RawText2.default.describe(),function(){
return new _RawText2.default(guiSys);
});
_this.registerViewType('Video',_Video2.default.describe(),function(){
return new _Video2.default(guiSys,rnctx);
});
_this.registerViewType('VideoPano',_VideoPano2.default.describe(),function(){
return new _VideoPano2.default(guiSys,rnctx);
});
_this.registerViewType('AmbientLight',_AmbientLight2.default.describe(),function(){
return new _AmbientLight2.default(guiSys);
});
_this.registerViewType('DirectionalLight',_DirectionalLight2.default.describe(),function(){
return new _DirectionalLight2.default(guiSys);
});
_this.registerViewType('PointLight',_PointLight2.default.describe(),function(){
return new _PointLight2.default(guiSys);
});
_this.registerViewType('SpotLight',_SpotLight2.default.describe(),function(){
return new _SpotLight2.default(guiSys);
});
_this.registerViewType('CylindricalPanel',_CylindricalPanel2.default.describe(),function(){
return new _CylindricalPanel2.default(guiSys);
});
_this.registerViewType('QuadPanel',_QuadPanel2.default.describe(),function(){
return new _QuadPanel2.default(guiSys);
});
_this.registerViewType('Box',_Box2.default.describe(),function(){
return new _Box2.default(guiSys,rnctx);
});
_this.registerViewType('Cylinder',_Cylinder2.default.describe(),function(){
return new _Cylinder2.default(guiSys,rnctx);
});
_this.registerViewType('Plane',_Plane2.default.describe(),function(){
return new _Plane2.default(guiSys,rnctx);
});
_this.registerViewType('Sphere',_Sphere2.default.describe(),function(){
return new _Sphere2.default(guiSys,rnctx);
});
_this.registerViewType('Prefetch',_Prefetch2.default.describe(),function(){
return new _Prefetch2.default(guiSys);
});

customViews.forEach(function(_ref){var name=_ref.name,view=_ref.view;
_this.registerViewType(name,view.describe(),function(){
return new view(guiSys);
});
});return _this;
}

/**
   * Creates a new view of type under rootTag
   * @param tag - Unique react tag id to create view with
   * @param type - The type of view to create, must have been registered
   * @param rootTag - the root React Tag to create this view under
   * @param attr - object containing attributes to set
   */babelHelpers.createClass(UIManager,[{key:"createView",value:function createView(
tag,type,rootTag,attr){
var newView=this._viewCreator[type]();
this._views[String(tag)]=newView;
newView.UIManager=this;
newView.tag=tag;
// assign the tag to the three.js view if created
if(newView.view){
newView.view.tag=tag;
}
newView.rootTag=rootTag;
// record the type of view created
this._viewTypes[String(tag)]=type;
// record the tags associated with type for later lookup
this._viewsOfType[type][String(tag)]=newView;
// assign the default properties to the view
this.updateView(tag,type,attr);
// force the view to be marked as dirty
this._views[String(tag)].makeDirty();
return this._views[String(tag)];
}

/**
   * sets the children tags for tag
   * Fast path for initial creation of views
   * @param tag - Unique react tag id to allow look up of view object
   * @param childrenTags - array of the the tag ids that will be children of tag
   */},{key:"setChildren",value:function setChildren(
tag,childrenTags){
// look up the view
var viewToManage=this._views[String(tag)];
// iterate through the children
for(var i=0;i<childrenTags.length;i++){
// add viewToAdd as a child of viewToManage as index i
var viewToAdd=this._views[String(childrenTags[i])];
if(viewToAdd){
viewToManage.addChild(i,viewToAdd);
viewToAdd.setParent(viewToManage);
// make sure the view is marked as dirty
viewToAdd.makeDirty();
}
}
}

/**
   * manages children of a specific tag
   * Handles moving, adding and removing with a specific order defined in
   * the react code
   * other than tag any value could be null
   * @param tag - Unique react tag id to allow look up of view object
   * @param moveFrom - array of indices of child of view tag to move from
   * @param moveTo - array of indices of child of view tag to move to
   * @param addChildTags - array of the tag ids that will be children of tag
   * @param addAtIndices - array of the indices to add children at
   * @param removeFrom - array of the indices in view of tag which should
   *                     be removed and purged
   */},{key:"manageChildren",value:function manageChildren(

tag,
moveFrom,
moveTo,
addChildTags,
addAtIndices,
removeFrom)
{
var cssNodeToManage=this._views[String(tag)];
if(!cssNodeToManage){
return;
}

// determine counts with checks for null
var numToMove=!moveFrom?0:moveFrom.length;

// We treat moves as an add and a delete
var viewsToAdd=[];
var indicesToRemove=[];
var tagsToRemove=[];
var tagsToDelete=[];

// moves are based on a series of adds after removes
if(moveFrom&&moveTo){
for(var i=0;i<moveFrom.length;i++){
var moveFromIndex=moveFrom[i];
var tagToMove=cssNodeToManage.getChild(moveFromIndex).getTag();
viewsToAdd[i]={
tag:tagToMove,
index:moveTo[i]};

indicesToRemove[i]=moveFromIndex;
tagsToRemove[i]=tagToMove;
}
}

// add the rest of the adds
if(addChildTags){
for(var _i=0;_i<addChildTags.length;_i++){
var viewTagToAdd=addChildTags[_i];
var indexToAddAt=addAtIndices[_i];
viewsToAdd[numToMove+_i]={
tag:viewTagToAdd,
index:indexToAddAt};

}
}

// now add the required removes
if(removeFrom){
for(var _i2=0;_i2<removeFrom.length;_i2++){
var indexToRemove=removeFrom[_i2];
var tagToRemove=cssNodeToManage.getChild(indexToRemove).getTag();
indicesToRemove[numToMove+_i2]=indexToRemove;
tagsToRemove[numToMove+_i2]=tagToRemove;
tagsToDelete[_i2]=tagToRemove;
}
}

// NB: moveFrom and removeFrom are both relative to the starting state of the View's children.
// moveTo and addAt are both relative to the final state of the View's children.
//
// 1) Sort the views to add and indices to remove by index
// 2) Iterate the indices being removed from high to low and remove them. Going high to low
//    makes sure we remove the correct index when there are multiple to remove.
// 3) Iterate the views being added by index low to high and add them. Like the view removal,
//    iteration direction is important to preserve the correct index.

viewsToAdd.sort(function(a,b){
return a.index-b.index;
});
indicesToRemove.sort(function(a,b){
return a-b;
});

// Apply changes to node hierarchy
// removing in the order last index to first index
for(var _i3=indicesToRemove.length-1;_i3>=0;_i3--){
cssNodeToManage.removeChild(indicesToRemove[_i3]);
}

// add the new children
for(var _i4=0;_i4<viewsToAdd.length;_i4++){
var viewAtIndex=viewsToAdd[_i4];
var cssNodeToAdd=this._views[String(viewAtIndex.tag)];
cssNodeToManage.addChild(viewAtIndex.index,cssNodeToAdd);
cssNodeToAdd.setParent(cssNodeToManage);
cssNodeToAdd.makeDirty();
}

// finally purge the deleted views and their hierarchy
for(var _i5=0;_i5<tagsToDelete.length;_i5++){
this.purgeView(this._views[String(tagsToDelete[_i5])]);
}
}

/**
   * registers the view type and the function to create the view
   * @param name - name of view type to create should correspond to react register view code
   * @param view - description of the view that includes the properties that it supports
   * @param viewCreator - function that returns a created view
   */},{key:"registerViewType",value:function registerViewType(
name,view,viewCreator){
// Flow doesn't like computed properties on classes
this[name]=view;
this._viewCreator[name]=viewCreator;
this._viewsOfType[name]={};
}

/**
   * applies the attributes in the attr object to the view
   * @param tag - react tag id
   * @param type - view type
   * @param attr - object contained attributes to set
   */},{key:"updateView",value:function updateView(
tag,type,attr){
var view=this._views[String(tag)];
var forceLayout=false;
for(var a in attr){
// use the declaration of the NativeProps to determine if this
// attribute is a style type or property
if(this[type]&&this[type].NativeProps[a]){
view.props[a]=attr[a];
}else{
/* $FlowFixMe */
if(typeof view['_'+a]==='function'){
/* $FlowFixMe */
view['_'+a](attr[a]);
}else{
view.style[a]=attr[a];
}
// check attribute is not in black list before forcing layout
forceLayout=forceLayout||!STYLES_THAT_DONT_ALTER_LAYOUT[a];
}
}
// force a layout if any layout styles are applied
if(forceLayout){
view.makeDirty();
}
// call update of view if required
if(typeof view.updateView==='function'){
view.updateView();
}
}

/**
   * removes the view and the hierarchy of child views under it
   * @param param0 -
   */},{key:"purgeView",value:function purgeView(
view){
// make sure any parent views are marked as dirty
view.makeDirty();
// shutdown the view making sure any resources are released
view.dispose();
// delete entries in looks
var type=this._viewTypes[String(view.tag)];
delete this._viewTypes[String(view.tag)];
delete this._views[String(view.tag)];
delete this._viewsOfType[type][String(view.tag)];
// purge children
for(var i=0;i<view.children.length;i++){
this.purgeView(view.children[i]);
}
// clear the array
view.children=[];
}

/**
   * creates a root view, this should be called by the context to
   * ensure the strict tag ID is used
   * root view tags IDs are always (multiples of ten + one)
   * @param tag - react tag to use
   */},{key:"createRootView",value:function createRootView(
tag,container){
// create a View with defaults
this._rootViews[String(tag)]=this.createView(tag,'RCTView',tag,{});
this._guiSys.add(this._rootViews[String(tag)].view,container);
}

/**
   * remove root view and all child views
   * @param tag - react tag to delete
   */},{key:"removeRootView",value:function removeRootView(
tag){
var view=this._views[String(tag)];
if(!view){
return;
}

// delete entry in lookup
delete this._rootViews[String(tag)];
this.purgeView(view);
}

/**
   * moves a view newReactTag to the space filled by reactTag
   * add remove reactTag
   * @param reactTag - react tag to remove
   * @param newReactTag - react tag to move to location of reactTag
   */},{key:"replaceExistingNonRootView",value:function replaceExistingNonRootView(
reactTag,newReactTag){
var view=this._views[String(reactTag)];
if(!view){
return;
}
view.makeDirty();

var superView=view.getParent();
if(!superView){
return;
}

var indexOfView=superView.getIndexOf(view);
if(indexOfView===-1){
return;
}

// call through to manageChildren to do the general work
this.manageChildren(
superView.getTag(),
null,
null,
[newReactTag],
[indexOfView],
[indexOfView]);

}

/**
   * removes all the children of view tag
   * @param tag - read Tag of view
   */},{key:"removeSubviewsFromContainerWithID",value:function removeSubviewsFromContainerWithID(
tag){
var view=this._views[String(tag)];
if(!view){
return;
}
// make sure view at it's parents are marked dirty to cause relayout
view.makeDirty();

var removeIndex=[];
for(var childIndex=0;childIndex<view.getChildCount();childIndex++){
removeIndex.push(childIndex);
}

for(var i=removeIndex.length-1;i>=0;i--){
var childView=view.getChild(removeIndex[i]);
this.purgeView(childView);
childView.setParent(null);
view.removeChild(removeIndex[i]);
}
}

/**
   * Apply the computed layout to the view and it's parents
   * @param view - view object to operate on
   */},{key:"presentLayout",value:function presentLayout(
view){
// apply the view specific layout changes
if(view.presentLayout){
view.presentLayout();
}
view.isDirty=false;
for(var i=0;i<view.children.length;i++){
this.presentLayout(view.children[i]);
}
}

/**
   * frame update for the UI
   */},{key:"frame",value:function frame(
frameStart){
// call frame function for each view
// optimization is to register interest in update
if(this._lastFrameStart<0){
this._lastFrameStart=frameStart;
}
var deltaTime=frameStart-this._lastFrameStart;
this._lastFrameStart=frameStart;
for(var _tag in this._views){
this._views[_tag].frame(frameStart,deltaTime);
}
// layout the views
this.layout();
}

/**
   * layout the views using css-layout
   */},{key:"layout",value:function layout()
{
// loop through all root views
for(var _tag2 in this._rootViews){
// This relies on css-layout.js, which is a subset of flexbox layout algorithm (based on comments).
// Called recursively to layout subtrees of flexbox tree. Uses node.style.
var rootView=this._rootViews[_tag2];
// use css-layout flex box to apply new flow
rootView.YGNode.calculateLayout(Yoga.UNDEFINED,Yoga.UNDEFINED,Yoga.DIRECTION_LTR);
// present the layout to the view implementations from root to child
this.presentLayout(rootView);
}
}

/**
   * Returns the transform for the first ReactVR <Scene> within the rootTag,
   * or null if there is no <Scene> or the <Scene> has no transform property.
   * @param rootTag - root view tag to look for Scene under
   */},{key:"getSceneCameraTransform",value:function getSceneCameraTransform(
rootTag){
var scenes=this._viewsOfType['Scene'];
if(!scenes||Object.keys(scenes).length===0){
return null;
}
var scene=function(scenes,rootTag){
for(var _tag3 in scenes){
var item=scenes[_tag3];
if(item.rootTag===rootTag){
return item;
}
}
}(scenes,rootTag);
return scene&&scene.style&&scene.style.transform;
}

/**
   * Returns the layers view
   * @param rootTag - root view tag to look for Scene under
   */},{key:"getLayers",value:function getLayers()
{
var CylindricalPanels=this._viewsOfType['CylindricalPanel'];
return CylindricalPanels;
}

/**
   * Configure the cursor
   */},{key:"setCursorVisibility",value:function setCursorVisibility(
visibility){
this._guiSys.setCursorVisibility(visibility);
}

/**
   * Util function that given text requirements returns the height of the text
   */},{key:"measureTextHeight",value:function measureTextHeight(

text,
fontSize,
width,
maxLineCount,
callbackID)
{
var wordWrapped=OVRUI.wrapLines(
this._guiSys.font,
text,
fontSize,
width,
undefined,
maxLineCount);

var dim=OVRUI.measureText(this._guiSys.font,wordWrapped,fontSize);
this._rnctx.invokeCallback(callbackID,[dim.maxHeight]);
}

/**
   * Attach or remove a bounding box mesh. This is used by React Devtools to
   * show the currently-highlighted component.
   */},{key:"setBoundingBoxVisible",value:function setBoundingBoxVisible(
tag,visible){
var view=this._views[String(tag)];
var uiView=view.view;
if(!uiView){
return;
}
var previous=null;
uiView.children.forEach(function(c){
if(c.__REACT_VR_BOUNDING){
previous=c;
}
});
if(visible){
if(previous){
return;
}
var bounds=new THREE.Box3();
bounds.setFromObject(uiView);
var boundViz=new THREE.Mesh(
new THREE.BoxGeometry(
bounds.max.x-bounds.min.x,
bounds.max.y-bounds.min.y,
bounds.max.z-bounds.min.z,
1,
1,
1),

new THREE.MeshBasicMaterial({wireframe:true,color:0xe44dd9}));

boundViz.__REACT_VR_BOUNDING=true;
uiView.add(boundViz);
}else{
if(!previous){
return;
}
uiView.remove(previous);
}
}

/**
   * Determines the location on screen, width, and height of the given view and returns the values
   * via an async callback.
   */},{key:"measure",value:function measure(
reactTag,callback){
var view=this._views[String(reactTag)];
if(!view){
this._rnctx.invokeCallback(callback,[]);
return;
}
var x=0;
var y=0;
var w=view.YGNode.getComputedWidth();
var h=view.YGNode.getComputedHeight();
while(view){
x+=
view.YGNode.getComputedLeft()-view.YGNode.getComputedWidth()*view.style.layoutOrigin[0];
y+=
view.YGNode.getComputedTop()-view.YGNode.getComputedHeight()*view.style.layoutOrigin[1];
view=view.getParent();
}
// [x, y, w, h, left, top]
this._rnctx.invokeCallback(callback,[0,0,w,h,x,y]);
}

/**
   * Determines the location on screen, width, and height of the given view relative to the device
   * screen and returns the values via an async callback.  This is the absolute position including
   * things like the status bar
   */},{key:"measureInWindow",value:function measureInWindow(
reactTag,callback){
var view=this._views[String(reactTag)];
if(!view){
this._rnctx.invokeCallback(callback,[]);
return;
}
var x=0;
var y=0;
var w=view.YGNode.getComputedWidth();
var h=view.YGNode.getComputedHeight();
while(view){
x+=
view.YGNode.getComputedLeft()-view.YGNode.getComputedWidth()*view.style.layoutOrigin[0];
y+=
view.YGNode.getComputedTop()-view.YGNode.getComputedHeight()*view.style.layoutOrigin[1];
view=view.getParent();
}
this._rnctx.invokeCallback(callback,[x,y,w,h]);
}

/**
   * Measures the view specified by tag relative to the given ancestorTag. This means that the
   * returned x, y are relative to the origin x, y of the ancestor view. Results are stored in the
   * given outputBuffer. We allow ancestor view and measured view to be the same, in which case
   * the position always will be (0, 0) and method will only measure the view dimensions.
   *
   * NB: Unlike {@link #measure}, this will measure relative to the view layout, not the visible
   * window which can cause unexpected results when measuring relative to things like ScrollViews
   * that can have offset content on the screen.
   */},{key:"measureLayout",value:function measureLayout(

reactTag,
ancestorTag,
errorCallback,
successCallback)
{
var view=this._views[String(reactTag)];
if(!view){
this._rnctx.invokeCallback(errorCallback,[]);
return;
}
var x=0;
var y=0;
var w=view.YGNode.getComputedWidth();
var h=view.YGNode.getComputedHeight();
while(view&&view.tag!==ancestorTag){
x+=
view.YGNode.getComputedLeft()-view.YGNode.getComputedWidth()*view.style.layoutOrigin[0];
y+=
view.YGNode.getComputedTop()-view.YGNode.getComputedHeight()*view.style.layoutOrigin[1];
view=view.getParent();
}
this._rnctx.invokeCallback(successCallback,[x,y,w,h]);
}

/**
   * Like {@link #measure} and {@link #measureLayout} but measures relative to the immediate parent.
   *
   * NB: Unlike {@link #measure}, this will measure relative to the view layout, not the visible
   * window which can cause unexpected results when measuring relative to things like ScrollViews
   * that can have offset content on the screen.
   */},{key:"measureLayoutRelativeToParent",value:function measureLayoutRelativeToParent(
reactTag,errorCallback,successCallback){
var view=this._views[String(reactTag)];
if(!view){
this._rnctx.invokeCallback(successCallback,[]);
return;
}
var x=
view.YGNode.getComputedLeft()-view.YGNode.getComputedWidth()*view.style.layoutOrigin[0];
var y=
view.YGNode.getComputedTop()-view.YGNode.getComputedHeight()*view.style.layoutOrigin[1];
var w=view.YGNode.getComputedWidth();
var h=view.YGNode.getComputedHeight();
this._rnctx.invokeCallback(successCallback,[x,y,w,h]);
}

/**
   * Configure an animation to be used for the native layout changes, and native views
   * creation. The animation will only apply during the current batch operations.
   *
   * callbacks are not supported, this feature will likely be killed.
   *
   * @param config the configuration of the animation for view addition/removal/update.
   * @param success not supported
   * @param error not supported
   */},{key:"configureNextLayoutAnimation",value:function configureNextLayoutAnimation(
config,finished,error){
this._layoutAnimation=config;
}

/**
   * Dispatch a command to a specific native view. This can be called from JS side to invoke
   * function on a native view.
   *
   * @param reactTag - react tag id
   * @param commandId - the command id for the native view to invoke different functions
   * @param commandArgs - the arguments of the command
   */},{key:"dispatchViewManagerCommand",value:function dispatchViewManagerCommand(
reactTag,commandId,commandArgs){
var view=this._views[String(reactTag)];
if(!view){
console.warn("UIManager.dispatchViewManagerCommand: dispatching command on a nonexistent view: "+
reactTag);

return;
}
view.receiveCommand(commandId,commandArgs);
}

//TODO:
//findSubviewIn
}]);return UIManager;}(_Module3.default);exports.default=UIManager;