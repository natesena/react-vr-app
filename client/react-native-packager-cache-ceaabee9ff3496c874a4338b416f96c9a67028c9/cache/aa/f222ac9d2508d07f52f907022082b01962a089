Object.defineProperty(exports,"__esModule",{value:true});










var _three=require("three");var THREE=babelHelpers.interopRequireWildcard(_three);
var _extractURL=require("../Utils/extractURL");var _extractURL2=babelHelpers.interopRequireDefault(_extractURL);



var _threeGltf2Loader=require("three-gltf2-loader");var _threeGltf2Loader2=babelHelpers.interopRequireDefault(_threeGltf2Loader);
var _RefCountCache=require("../Utils/RefCountCache");var _RefCountCache2=babelHelpers.interopRequireDefault(_RefCountCache);/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */(0,_threeGltf2Loader2.default)(THREE);function recursiveDispose(node){if(typeof node.dispose==='function'){node.dispose();}if(node.geometry){node.geometry.dispose();
}
if(node.material){
node.material.dispose();
}
for(var _iterator=node.children,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[typeof Symbol==="function"?Symbol.iterator:"@@iterator"]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var child=_ref;
recursiveDispose(child);
}
}

var gltfStateCache=new _RefCountCache2.default(function(url,entry){
recursiveDispose(entry.scene);
});
var loadList={};var

GLTF2MeshInstance=function(){








function GLTF2MeshInstance(definition,parent){var _this=this;babelHelpers.classCallCheck(this,GLTF2MeshInstance);
this.url=(0,_extractURL2.default)(definition.gltf2)||'';
this.parent=parent;
this.mixer=null;
this.timeStamp=-1;
this.activeAnimations={};
this.allAnimations={};

var onLoad=function onLoad(gltf){
if(gltfStateCache.has(_this.url)){
gltfStateCache.addReference(_this.url);
}else{



}// disabling until gltf clone issue is resolved
// https://github.com/mrdoob/three.js/issues/11573
//gltfStateCache.addEntry(this.url, gltf);
// https://github.com/mrdoob/three.js/issues/11573
//this.scene = gltf.scene.clone();
_this.scene=gltf.scene;_this.mixer=new THREE.AnimationMixer(_this.scene);

// load the animations into the mixer
var animations=gltf.animations;
if(animations&&animations.length){
for(var i=0;i<animations.length;i++){
var animation=animations[i];
_this.allAnimations[animation.name]=_this.mixer.clipAction(animation);
}
}

// apply the definition animation settings
_this.updateAnimation(definition);

// need to wait a frame for other attributes to setup
// FIXME
requestAnimationFrame(function(){
parent.add(_this.scene);
});
};

// file is ready and downloaded use the cache
if(gltfStateCache.has(this.url)){
onLoad(gltfStateCache.get(this.url));
return;
}

// if started to download append the callback
if(loadList[this.url]){
loadList[this.url].push(onLoad);
return;
}

// disabling as there a problems with cloning gltf models
// https://github.com/mrdoob/three.js/issues/11573
//loadList[this.url] = [onLoad];

// $FlowFixMe
var loader=new THREE.GLTF2Loader();
loader.load(
this.url,
function(gltf){
onLoad(gltf);
/*for (const callback of loadList[this.url]) {
          callback(gltf);
        }
        delete loadList[this.url];*/
},
function(){},
function(){
console.error('failed to load GLTF',_this.url);
delete loadList[_this.url];
});

}babelHelpers.createClass(GLTF2MeshInstance,[{key:"updateAnimation",value:function updateAnimation(

definition){
if(!definition.animations||definition.animations.length===0){
if(this.mixer){
this.activeAnimations={};
this.mixer.stopAllAction();
}
return;
}
// stop any leftover animations
var newActiveAnimations={};
for(var key in definition.animations){
var animName='animation_'+key;
newActiveAnimations[animName]=true;
// start animations which have yet to be started
if(this.allAnimations[animName]){
var anim=this.allAnimations[animName];
var params=definition.animations[key];
if(params){
anim.fadeIn(params.fadeTime?params.fadeTime:0);
anim.setEffectiveTimeScale(params.timeScale?params.timeScale:1);
anim.setEffectiveWeight(params.weight?params.weight:1);
if(params.syncWith&&this.allAnimations[params.syncWith]){
anim.syncWith(this.allAnimations[params.syncWith]);
}
}

if(!this.activeAnimations[animName]){
anim.play();
}
}
delete this.activeAnimations[animName];
}
// stop any leftover animations
for(var _key in this.activeAnimations){
if(this.allAnimations[_key]){
this.allAnimations[_key].stop();
}
}
this.activeAnimations=newActiveAnimations;
}},{key:"update",value:function update(

definition){
// we can update some params without the need to reload the instance
// if the url is the same let's assume the model hasn't changed
var newUrl=(0,_extractURL2.default)(definition.gltf2)||'';
if(newUrl!==this.url){
return false;
}
// apply animation changes
this.updateAnimation(definition);
return true;
}},{key:"frame",value:function frame(

timeStampMS,deltaTimeMS){
if(this.mixer){
this.mixer.update(deltaTimeMS*0.001);
}
}

// already established apis
},{key:"setLit",value:function setLit(flag){



}},{key:"setTexture",value:function setTexture(

value){



}},{key:"setWireframe",value:function setWireframe(

value){



}},{key:"dispose",value:function dispose()

{
if(this.scene){
gltfStateCache.removeReference(this.url);
this.parent.remove(this.scene);
delete this.scene;
}
}}]);return GLTF2MeshInstance;}();var


GLTF2ModelLoader=function(){function GLTF2ModelLoader(){babelHelpers.classCallCheck(this,GLTF2ModelLoader);}babelHelpers.createClass(GLTF2ModelLoader,[{key:"canLoad",
// returns true if the loader can create an instance from this definition
value:function canLoad(definition){
return definition&&definition.hasOwnProperty('gltf2');
}

// create the instance
},{key:"createInstance",value:function createInstance(
definition,
parent,
litMaterial,
unlitMaterial)
{
return new GLTF2MeshInstance(definition,parent);
}}]);return GLTF2ModelLoader;}();exports.default=GLTF2ModelLoader;