Object.defineProperty(exports,"__esModule",{value:true});exports.





















fetchAndCacheOBJ=fetchAndCacheOBJ;exports.






























removeOBJReference=removeOBJReference;var _OBJParser=require("./OBJParser");var _RefCountCache=require("../../Utils/RefCountCache");var _RefCountCache2=babelHelpers.interopRequireDefault(_RefCountCache);var _fetchResource=require("../../Utils/fetchResource");var _fetchResource2=babelHelpers.interopRequireDefault(_fetchResource);// We currently use OBJLoader as a singleton, but we may want to create one
// per ReactNativeContext later on
var objStateCache=new _RefCountCache2.default();/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */var objLoaders={};function fetchAndCacheOBJ(obj){if(objStateCache.has(obj)){objStateCache.addReference(obj);return Promise.resolve(objStateCache.get(obj));}// Make sure we only load + parse parallel OBJ requests once
var objLoader=objLoaders[obj];if(!objLoader){objLoader=(0,_fetchResource2.default)(obj).then(function(text){return(0,_OBJParser.readOBJFile)(text);});objLoaders[obj]=objLoader;}return objLoader.then(function(state){if(objStateCache.has(obj)){objStateCache.addReference(obj);}else{objStateCache.addEntry(obj,state);}// Perform cleanup of the Promise after adding an entry to the cache.
// If cleanup were performed at the end of the original Loader promise,
// there would be one event tick between removing the loader and adding
// the cache entry, allowing a (slim) chance for an unnecessary second load.
if(obj in objLoaders){delete objLoaders[obj];}return state;});}function removeOBJReference(key){objStateCache.removeReference(key);}